Задание 1
2 ** 16
возводим 2 в степень 16, получаем 65536

2 / 5, 2 / 5.0
два деления — первое целыми, второе с float, оба дают 0.4, результат — кортеж

"spam" + "eggs"
две строки складываются, получается 'spameggs'

S = "ham"
создается переменная S со значением 'ham', ничего не выводится

"eggs " + S
строки складываются, получается 'eggs ham'

S * 5
повторяем строку 5 раз, получаем 'hamhamhamhamham'

S[:0]
срез от начала до индекса 0, результат — пустая строка

"green %s and %s" % ("eggs", S)
старый способ форматирования строк, подставляются значения, результат 'green eggs and ham'

'green {0} and {1}'.format('eggs ', S)
новый способ форматирования, аналогично — результат 'green eggs and ham'

('x',)[0]
доступ к первому элементу кортежа, получаем 'x'

('x', 'y')[1]
берем второй элемент кортежа, результат 'y'

L = [1,2,3] + [4,5,6]
создается список, объединение двух списков, результат [1,2,3,4,5,6], но не выводится

L, L[:], L[:0], L[-2], L[-2:]
выводим сам список, копию, пустой срез, предпоследний элемент и последние два — результат: ([1,2,3,4,5,6], [1,2,3,4,5,6], [], 5, [5,6])

([1,2,3] + [4,5,6])[2:4]
склеиваем списки и берем срез от 2 до 4, результат [3, 4]

[L[2], L[3]]
создаем новый список из элементов с индексами 2 и 3, результат [3, 4]

L.reverse(); L
переворачиваем список на месте, метод ничего не возвращает, но потом L содержит перевернутый список

L.sort(); L
сортируем список на месте, потом смотрим на результат — отсортированный список

L.index(4)
ищем индекс элемента 4 в списке, результат 3

{'a':1, 'b':2}['b']
создаем словарь и сразу берем значение по ключу 'b', получаем 2

D = {'x':1, 'y':2, 'z': 3}
создаем словарь с тремя парами, ничего не выводится

D['w'] = 0
добавляем новую пару ключ-значение в словарь, ничего не выводится

D['x'] + D['w']
берем значения по ключам и складываем — 1 + 0 = 1

D[(1,2,3)] = 4
используем кортеж как ключ — это работает, потому что кортеж — неизменяемый тип

list(D.keys()), list(D.values()), (1,2,3) in D
получаем список ключей, список значений и проверяем, есть ли кортеж в ключах — результат (ключи, значения, True)

[[]], ["", (), {}, None]
два списка: один содержит пустой список, второй — разные пустые объекты и None, результат: [[]], ["", (), {}, None]

Задание 2
Индексация и нарезание
L = [0, 1, 2, 3]
создаем список из четырёх элементов

а) L[4]
ошибка — индекс за пределами списка

б) L[-1000:100]
срез работает — не вызывает ошибку, просто возвращает весь список, что есть

в) L[3:1]
срез с неправильным направлением — результат пустой список

L[3:1] = ['?']
вставляем строку '?' на место среза — она встаёт перед вторым индексом, то есть между элементами с индексами 1 и 2

Задание 3
Индексация, нарезание и оператор del
L = [0, 1, 2, 3]
создаем список из четырёх элементов

L[2] = []
по индексу 2 присваиваем пустой список — теперь элемент с индексом 2 это список [], результат: [0, 1, [], 3]

L[2:3] = []
удаляем срез с одного элемента — элемент по индексу 2 исчезает, результат: [0, 1, 3]

del L[0]
удаляем первый элемент списка, результат: [1, 3]

del L[1:]
удаляем всё от индекса 1 и до конца, остаётся только первый элемент, результат: [1]

L[1:2] = 1
ошибка — нельзя присвоить срезу не-последовательность

Задание 4
переменные меняются местами — теперь X равно 'eggs', а Y — 'spam'
так работает параллельное присваивание с распаковкой кортежей без временных переменных
Задание 5
Строки, целые числа и кортежи относятся к неизменяемым типам данных, которые подходят для ключей в словаре. Это объясняет, почему они работают как ключи, а списки или другие изменяемые объекты — нет.
Задание 6
Если обратиться к несуществующему ключу словаря, Python выдаст ошибку KeyError.
Если присвоить значение новому ключу, словарь расширится и ключ добавится.
В списках так нельзя: обращение за пределы индекса — ошибка, присвоить нельзя.
В словарях ключи это как имена переменных, их можно создавать динамично.
В списках индексы это фиксированные позиции, их нельзя пропускать.
Задание 7
а) При сложении разных типов, например строка + список, Python выдаст ошибку — типы несовместимы

б) Словари нельзя складывать с другими типами с помощью +, это вызовет ошибку

в) Метод append есть только у списков, строки не поддерживают append, а у списков нет метода keys

г) Результат среза или конкатенации двух списков — новый список; для строк — новая строка
Задание 8
В случае S[0][0][0][0][0], Python сначала берет первый символ строки S[0], это 's' — строка из одного символа.

Потом к этому символу снова применяется [0], но 's' — это тоже строка длиной 1, поэтому 's'[0] снова 's'.
Задание 9 
Присваивание по индексу невозможно, а изменение через срез и конкатенацию работает, так как создаётся новая строка.
Задание 10
Да, некоторые структуры более подходя
Задание 11
Файл появляется в той папке, где запущен код — это рабочая директория проекта или терминала.

Если в функции open указать путь, например "data/myfile.txt", файл создастся в папке data относительно текущей директории, но сама папка должна существовать, иначе будет ошибка.

Метод write не добавляет символ новой строки автоматически, нужно писать явно: "Hello file world!\n".


