1. Написание базовых циклов

a) Вывод кодов ASCII
for char in S:
    print(ord(char))   #функция возвращает код ASCII (или кодовую точку Unicode) символа.

б) Сумма кодов ASCII
sum_ascii = 0
for char in S:
    sum_ascii += ord(char)
print("Сумма кодов ASCII:", sum_ascii)

в) Список кодов ASCII
list_ascii = []
for char in S:
    list_ascii.append(ord(char))
print("Список кодов ASCII:", list_ascii)

Сравнение с map и list comprehension
print("map(ord, S):", list(map(ord, S)))   #применяет функцию ord к каждому элементу в S. map возвращает итератор, поэтому для получения списка используем list().
print("[ord(c) for c in S]:", [ord(c) for c in S])   #это list comprehension. он создает новый список, вычисляя выражение ord(c) для каждого c в строке S.

Оба подхода (map и list comprehension) достигают одной и той же цели:
преобразовать каждый символ в строке в его код ASCII и создать список из этих кодов.
Разница заключается в синтаксисе и в производительности
(list comprehension немного быстрее).

2. Символы обратной косой, черты.

for i in range(50):
    print('hello %d\n\a' % i)

Цикл выполнится 50 раз.
1) В каждой итерации будет выводиться строка "hello" с номером итерации (i).
2) \n вставит новую строку (выполнится перенос на следующую строку).
3) \a попытается издать звуковой сигнал. В IDLE вместо звукового сигнала
будет отображаться специальный символ или ничего не произойдет.

3. Сортировка словарей.

my_dict = {'b': 2, 'a': 1, 'c': 3}

# Сортировка ключей и вывод
for key in sorted(my_dict.keys()):  # sorted возвращает отсортированный список
    print(key, my_dict[key])

1) my_dict.keys(): Возвращает view объект, содержащий ключи словаря.
2) sorted(my_dict.keys()): sorted() принимает iterable и возвращает новый отсортированный список.
3) Перебор отсортированных ключей позволяет вывести элементы словаря в отсортированном порядке ключей.


4. Альтернативные варианты программной логики.
Взгляните на показанный ниже код, в котором используется цикл while и флаг found для поиска в списке степеней 2 значения 2,
возведенного в пятую степень (32). Он хранится в файле модуля по имени power.ру.

L = [1, 2, 4, 8, 16, 32, 64]
X = 5
found = False
i = 0
while not found and i < len(L) :
    if 2**X == L[i] :
        found = True
    else:
        i = i + 1
if found:
    print('at index', i)
else:
    print(X, 'not found')

C: \book\tests> python power, py
at index 5

a) Переписываем с else цикла while:

L = [1, 2, 4, 8, 16, 32, 64]
X = 5
i = 0
while i < len(L):
    if 2**X == L[i]:
        print('at index', i)
        break  # Важно выйти из цикла
    i += 1
else:  # Выполнится, если цикл завершится нормально (не break)
    print(X, 'not found')

b) Переписываем с for циклом и else:

L = [1, 2, 4, 8, 16, 32, 64]
X = 5

for i, num in enumerate(L): # enumerate дает и индекс и значение
    if 2**X == num:
        print('at index', i)
        break
else:
    print(X, 'not found')

c) Устраняем цикл с помощью in:

L = [1, 2, 4, 8, 16, 32, 64]
X = 5

if 2**X in L:
    print('at index', L.index(2**X))
else:
    print(X, 'not found')

д) Улучшит ли производительность перенос выражения 2*X за пределы циклов? Каким образом вы представили бы это в коде?

Внутри цикла 2*X вычисляется несколько раз (в каждой итерации, пока не будет найдено соответствие, или до конца списка).
Вычисление степени (возведение в степень) может быть относительно затратной операцией, особенно если X - большое число.
Поэтому, если мы вычислим значение 2*X один раз и сохраним его в переменной, а затем будем использовать эту переменную в цикле, мы избежим повторных вычислений.

X = 5
power_of_2 = 2**X  # Вычисляем 2**X только один раз
L = [1, 2, 4, 8, 16, 32, 64]

if power_of_2 in L:
    print('at index', L.index(power_of_2))
else:
    print(X, 'not found')

е) Как мы видели в первом упражнении, Python содержит инструмент map(функция, список), который также способен генерировать список степеней 2: map(lambda x: 2 * x, range(7)).
Попробуйте набрать этот код в интерактивной подсказке. Поможет ли здесь списковое включение?

# Использование map()
L = list(map(lambda x: 2**x, range(7)))
print(L)  # Вывод: [1, 2, 4, 8, 16, 32, 64]

# Использование спискового включения
L = [2**x for x in range(7)]
print(L)  # Вывод: [1, 2, 4, 8, 16, 32, 64]

1) lambda x: 2*x: Это анонимная функция, которая принимает число x и возвращает 2 в степени x.
2) range(7): Это генератор последовательности чисел от 0 до 6 (не включая 7).
3) list(map(...)): map() возвращает итератор, а list() преобразует этот итератор в список.


X = 5
power_of_2 = 2**X
L = [2**x for x in range(7)]  # Генерируем список степеней 2

if power_of_2 in L:
    print('at index', L.index(power_of_2))
else:
    print(X, 'not found')

В последнем примере L больше не содержит степеней 2.
Будет выдан ответ, что X not found, так как 32 не входит в список [0, 2, 4, 6, 8, 10, 12].
Да, списковое включение определенно поможет.
Списковое включение предоставляет более компактный и обычно более читаемый способ достижения того же результата, что и map с lambda.

    

    
